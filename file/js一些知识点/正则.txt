. 是通配符 /.un/ 匹配 run pun bun
i 是忽略大小写 /un/i 匹配 un Un UN uN 
g 是全局匹配 
以上可组合使用如：gi

(正则).test(要匹配对象)
(要匹配对象).match(正则)

/li/ 文字精确匹配(由于无gi.所以只会匹配一个大小写一模一样
没有多的字符且只匹配最前面的)

[]是只匹配括号里面字符的字符集 
  /d[aiu]g/ 匹配 dag dig dug , dog不行因为中括号里没有o

- 是连字符 /[a-g]/ 匹配a到g之间的全部字符
  /[1-5]/ 匹配 1到5之间的全部字符

^ 在字符串插入就是否定字符集 /[^aeiou]/是匹配除了aeiou以外的全部字符
符号@#￥%&*也会被匹配

+匹配出现多次 或连续出现多次的字符 
用/a+/g匹配 abc 结果 a
用/a+/g匹配 aabc 或 abac 结果分别是 aa 和 a,a

* 匹配出现0次或多次的字符
/go*/ 匹配 gooooooooooood 结果是 goooooooooooo
匹配 gueysdj 结果是g
匹配 sxnixde 结果是 null(无)

正则表达式 中 默认 贪婪匹配 当然也有 懒惰匹配

在表达式中加上?变成懒惰匹配

贪婪匹配：匹配符合表达式的最长的字符串
懒惰匹配：匹配符合表达式的最短的字符串

^ 在表达式中插入则用于匹配字符串是否在起始位置
/^abc/ 匹配 abc song 是 ture
/^abc/ 匹配 song of abc 是 false

$ 在表达式中插入则用于匹配字符串是否在结束位置
用法与 ^ 相反
如/abc$/

\w 匹配最接近的元字符 
是/[A-Za-z0-9_]/的缩写
注意！这也包含字符_

\W 与 \w 的功能完全相反
是/[^A-Za-z0-9_]/ 的缩写

\d 只匹配数字
是/[0-9]/ 的缩写

\D 与 \d 的功能完全相反
是/[^0-9]/ 的缩写

\s 匹配空格、回车符、制表符、换页符和换行符。 
可以认为这类似于元字符 [ \r\t\f\n\v]

\S 搜寻非空格字符
 此匹配模式将不匹配空格、回车符、制表符、换页符和换行符。
 可以认为这类似于元字符 [^ \r\t\f\n\v]

{x,y} 匹配出现x次到y次之间的字符，指定匹配的上下限
如/h{3,7}/就是匹配出现了3到7次的h，
出现了2次或8次的都无法匹配

我们也可以只指定下限，不指定上限
如/h{3,}/这样就没有上限

可当我们的上限和下限相同时该怎么办？

是/h{3,3}/ ?  no,no！

应该是 /h{3}/ !!!!!!
这样就只能匹配出现了3次的h

有时候要匹配的东西可能有不确定是否存在的部分
所以在不确定的部分前面打上？如
color 和 colour 都要匹配
表达式就是/colou?r/
这样以上两个都能匹配

有两种先行断言：正向先行断言（positive lookahead）
和负向先行断言（negative lookahead）。

正向 需要查看表达式中提到的元素在要匹配的里面是否 存在
负向 需要查看表达式中提到的元素在要匹配的里面是否 不存在

正向 /(?=...)/
负向 /(?!...)/

示例：
qt /q(?!u)/ 可以匹配成功
意思是你得先 没有u ，我再来匹配看看有没有q然后匹配
qu /q(?=u)/ 可以匹配成功
意思是你得先 有  u ，我再来匹配看看有没有q然后匹配

我们可以用括号来检查字符组如
apple 和 abble 可以用/a(pp|bb)le/
这样以上两个都能匹配
但不能匹配aggle 以及其他第2\3位不是pp和bb的东西

/(\w+) \1 \1 /找到两个重复的字符串
(\w+) 正则 用于匹配任意字符
\1 有几个这个就匹配几个重复的符合正则的字符串

.replace用法是将用正则搜索到的内容进行替换
语法是  字符串.replace(正则,'要替换的内容')
也可以用$符号调换位置
如'$3 $1 $2'
就是把 one two three 替换成 three one two







